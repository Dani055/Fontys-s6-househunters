<!DOCTYPE html> <html> <body> <p>In order to see how robust my application is I decided to perform full chaos engineering and see how it behaves when random components are shut off without warning. This way, if there are any issues I can derive improvements and make the application better.</p><p>Usually these components would be shut off under very high load when the system can't possibly maintain such a heavy traffic and experiences a crash. However, it is quite difficult to replicate such a large traffic without a dedicated machine to execute the load testing. For this reason, I decided to simulate a system crash by just manually shutting off certain components when the whole application was running.</p><h3>1. Firstly I decided to shut off one of the microservices (bid microservice)</h3><p>On the frontend side, things are looking fine, The users are informed that the bids of a particular listing cannot be fetched.</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBL0xNQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--46c497233ad81dff35e117b11148660f8d110fa4/image_2024-05-30_093601514.png" data-key="2alno45bjs6hwfm550cjya2893fc">GCloud indicates that there is a problem with the deployment and I am notified that there are no pods serving that deployment.</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBL2pNQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--747b943643cf40dbd1234879c9b75cbb96173988/image_2024-05-30_094000636.png" data-key="ekf4qcsb9s5z7h3uuqwvauun6mpc"></p><p>Everything is good so far. The problem arises when a message is actually published to RabbitMQ. When a user creates a listing the bid microservice is supposed to pick up the event and create a local fragment. However, due to there being no listeners of the bid microservice, RabbitMQ actually removes the queue that they listen on. This results in the message being discarded, since RabbitMQ does not know that there are supposed to be listeners in the first place.</p><p>The way to solve this is with durable queues and exchanges. That way, they persist on the disk event through message broker restarts and disconnects of listeners. In code, it is just a simple parameter that needs to be included:</p><pre><code class="language-typescript">await channel.assertQueue("listingCreatedBidSub", { durable: true });</code></pre><p>Declared in this way, the exchanges and queues become durable, as indicated in RabbitMQ management.</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBODdMQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--d40770637222195b50b145f0a9724e6c3ae2c130/image_2024-05-29_194443637.png" data-key="6hxxlkuklt2b50770agpvdufe2zn"></p><p>As a result of this, even when there are no listeners of an exchange, RabbitMQ knows that there are supposed to be such and keeps the messages on standby, waiting for a microservice to process them.</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBOWZMQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--384224514c89712e459d377eae5bb42589bf2fd2/image_2024-05-29_195532240.png" data-key="2yy59ofemascmegl8t7y0m9k6074"></p><h3>2.Secondly, I tried shutting off the database.</h3><p>The application handled this better than expected. On the frontend side, users are getting 500 errors with no stack trace leaks, which is good.</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBd2JOQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--df8a88ee7c2d50279ce843587b7005268fa398cf/image_2024-05-30_095521339.png" data-key="fttw8dfagjqsdl1rpcib4xgvv58b"></p><p>Due to my robust monitoring I have implemented with Sentry, I am also immediately notified of a database connection issue.</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBd2ZOQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--500012b8349b8cad6a31490dbcadc29393b32223/image_2024-05-30_095606416.png" data-key="yjb3ojpw9ez70lmz092vgfkw36xt">No problems were found with the current implementation/setup when the database is shut off.</p><h3>3.Finally, I tried shutting off the message broker</h3><p>This is when things went haywire. Once all microservices were started (they do not start if there is a problem connecting with the message broker or database, that is by design. In such a case, I am again immediately notified through sentry) I shut off the message broker and tried using the application. At first, things seemingly worked. I could log in and create listings. I became notified through Sentry that the message broker channel is closed and there was an error publishing the messages.</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBeGpOQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--89ce40c2b8863d71af6f03f00c886fcd0551d236/image_2024-05-30_100409736.png" data-key="bchlbq7uly15v6kslb4m4aip2vdl"></p><p>However, the listing was still created in the listing-ms' database. This means that the microservices' datastores had become de-synced. What's even worse was that there was no way to sync them. Really complex syncing procedures and migrations would need to be performed in order to resolve such a simple issue.</p><p>Thinking about this, I had 2 simple ways to solve it. The first one would be to add a cron job that checks whether the connection to RabbitMQ is live and would be run every 5 seconds, for example. The problem, however, is that in some edge cases the microservices could still become desynced.</p><p>The second, better way was to utilize transactions. Initially, I initially though that was impossible, since I was using MongoDB, a non-relational database. However, after some research, it turns out that MongoDB does in fact support transactions.(<a target="_blank" rel="noopener noreferrer nofollow" href="https://www.mongodb.com/docs/manual/core/transactions/">https://www.mongodb.com/docs/manual/core/transactions/</a>)</p><p>This meant that I could commit the transaction only if the message about it was successfully published. This lead to the following code in the listing microservice's repository</p><pre><code class="language-typescript"> const session = await mongoose.startSession(); session.startTransaction() try { const [listing] = await ListingEntity.create([{ ...payload, images: [], creatorId: userId }], {session}); channel?.publish('listing_created', '', Buffer.from(JSON.stringify(listing))); await session.commitTransaction(); return listing as IListing } catch (error) { console.log("ABORTING TRANSACTION") await session.abortTransaction(); throw error; } finally { session.endSession(); console.log("ENDING SESSION"); }</code></pre><p>It utilizes a try/catch/finally block to start a session and transaction, and perform the necessary actions. If there was an error the transaction would be aborted, and finally, the session would be closed. Testing the code above with the message broker shut off, the following is printed to the console:</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBK1hMQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--7a221e42bafa0afe7a5344f8e189e4252180b97d/image_2024-05-29_201023214.png" data-key="jh62c1js3cjock4jk0a69mz3kgi8"></p><p>Inspecting the database, it can be seen that there are no listings created and the transaction was successfully aborted, with the microservices still in sync.</p><p><img src="https://portfolio.drieam.app/api/public/v1/blobs/545ea1b8-b9c6-4fdf-9e1d-cab50ed05fbf/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBK2ZMQXc9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--726731a38d62b4b88ab559f19cd481615fb7c87f/image_2024-05-29_201123167.png" data-key="1l77widg4flhld8e177hzm6o1bqv"></p> </body> </html>